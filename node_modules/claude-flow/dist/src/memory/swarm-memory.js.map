{"version":3,"sources":["../../../src/memory/swarm-memory.ts"],"sourcesContent":["import { EventEmitter } from 'node:events';\nimport { Logger } from '../core/logger.js';\nimport { MemoryManager } from './manager.js';\nimport { EventBus } from '../core/event-bus.js';\nimport { generateId } from '../utils/helpers.js';\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\n\nexport interface SwarmMemoryEntry {\n  id: string;\n  agentId: string;\n  type: 'knowledge' | 'result' | 'state' | 'communication' | 'error';\n  content: any;\n  timestamp: Date;\n  metadata: {\n    taskId?: string;\n    objectiveId?: string;\n    tags?: string[];\n    priority?: number;\n    shareLevel?: 'private' | 'team' | 'public';\n  };\n}\n\nexport interface SwarmMemoryQuery {\n  agentId?: string;\n  type?: SwarmMemoryEntry['type'];\n  taskId?: string;\n  objectiveId?: string;\n  tags?: string[];\n  since?: Date;\n  before?: Date;\n  limit?: number;\n  shareLevel?: SwarmMemoryEntry['metadata']['shareLevel'];\n}\n\nexport interface SwarmKnowledgeBase {\n  id: string;\n  name: string;\n  description: string;\n  entries: SwarmMemoryEntry[];\n  metadata: {\n    domain: string;\n    expertise: string[];\n    contributors: string[];\n    lastUpdated: Date;\n  };\n}\n\nexport interface SwarmMemoryConfig {\n  namespace: string;\n  enableDistribution: boolean;\n  enableReplication: boolean;\n  syncInterval: number;\n  maxEntries: number;\n  compressionThreshold: number;\n  enableKnowledgeBase: boolean;\n  enableCrossAgentSharing: boolean;\n  persistencePath: string;\n}\n\nexport class SwarmMemoryManager extends EventEmitter {\n  private logger: Logger;\n  private config: SwarmMemoryConfig;\n  private baseMemory: MemoryManager;\n  private entries: Map<string, SwarmMemoryEntry>;\n  private knowledgeBases: Map<string, SwarmKnowledgeBase>;\n  private agentMemories: Map<string, Set<string>>; // agentId -> set of entry IDs\n  private syncTimer?: NodeJS.Timeout;\n  private isInitialized: boolean = false;\n\n  constructor(config: Partial<SwarmMemoryConfig> = {}) {\n    super();\n    this.logger = new Logger('SwarmMemoryManager');\n    this.config = {\n      namespace: 'swarm',\n      enableDistribution: true,\n      enableReplication: true,\n      syncInterval: 10000, // 10 seconds\n      maxEntries: 10000,\n      compressionThreshold: 1000,\n      enableKnowledgeBase: true,\n      enableCrossAgentSharing: true,\n      persistencePath: './swarm-memory',\n      ...config,\n    };\n\n    this.entries = new Map();\n    this.knowledgeBases = new Map();\n    this.agentMemories = new Map();\n\n    const eventBus = EventBus.getInstance();\n    this.baseMemory = new MemoryManager(\n      {\n        backend: 'sqlite',\n        namespace: this.config.namespace,\n        cacheSizeMB: 50,\n        syncOnExit: true,\n        maxEntries: this.config.maxEntries,\n        ttlMinutes: 60,\n      },\n      eventBus,\n      this.logger,\n    );\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    this.logger.info('Initializing swarm memory manager...');\n\n    // Initialize base memory\n    await this.baseMemory.initialize();\n\n    // Create persistence directory\n    await fs.mkdir(this.config.persistencePath, { recursive: true });\n\n    // Load existing memory\n    await this.loadMemoryState();\n\n    // Start sync timer\n    if (this.config.syncInterval > 0) {\n      this.syncTimer = setInterval(() => {\n        this.syncMemoryState();\n      }, this.config.syncInterval);\n    }\n\n    this.isInitialized = true;\n    this.emit('memory:initialized');\n  }\n\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) return;\n\n    this.logger.info('Shutting down swarm memory manager...');\n\n    // Stop sync timer\n    if (this.syncTimer) {\n      clearInterval(this.syncTimer);\n      this.syncTimer = undefined;\n    }\n\n    // Save final state\n    await this.saveMemoryState();\n\n    this.isInitialized = false;\n    this.emit('memory:shutdown');\n  }\n\n  async remember(\n    agentId: string,\n    type: SwarmMemoryEntry['type'],\n    content: any,\n    metadata: Partial<SwarmMemoryEntry['metadata']> = {},\n  ): Promise<string> {\n    const entryId = generateId('mem');\n    const entry: SwarmMemoryEntry = {\n      id: entryId,\n      agentId,\n      type,\n      content,\n      timestamp: new Date(),\n      metadata: {\n        shareLevel: 'team',\n        priority: 1,\n        ...metadata,\n      },\n    };\n\n    this.entries.set(entryId, entry);\n\n    // Associate with agent\n    if (!this.agentMemories.has(agentId)) {\n      this.agentMemories.set(agentId, new Set());\n    }\n    this.agentMemories.get(agentId)!.add(entryId);\n\n    // Store in base memory for persistence\n    await this.baseMemory.remember({\n      namespace: this.config.namespace,\n      key: `entry:${entryId}`,\n      content: JSON.stringify(entry),\n      metadata: {\n        type: 'swarm-memory',\n        agentId,\n        entryType: type,\n        shareLevel: entry.metadata.shareLevel,\n      },\n    });\n\n    this.logger.debug(`Agent ${agentId} remembered: ${type} - ${entryId}`);\n    this.emit('memory:added', entry);\n\n    // Update knowledge base if applicable\n    if (type === 'knowledge' && this.config.enableKnowledgeBase) {\n      await this.updateKnowledgeBase(entry);\n    }\n\n    // Check for memory limits\n    await this.enforceMemoryLimits();\n\n    return entryId;\n  }\n\n  async recall(query: SwarmMemoryQuery): Promise<SwarmMemoryEntry[]> {\n    let results = Array.from(this.entries.values());\n\n    // Apply filters\n    if (query.agentId) {\n      results = results.filter((e) => e.agentId === query.agentId);\n    }\n\n    if (query.type) {\n      results = results.filter((e) => e.type === query.type);\n    }\n\n    if (query.taskId) {\n      results = results.filter((e) => e.metadata.taskId === query.taskId);\n    }\n\n    if (query.objectiveId) {\n      results = results.filter((e) => e.metadata.objectiveId === query.objectiveId);\n    }\n\n    if (query.tags && query.tags.length > 0) {\n      results = results.filter(\n        (e) => e.metadata.tags && query.tags!.some((tag) => e.metadata.tags!.includes(tag)),\n      );\n    }\n\n    if (query.since) {\n      results = results.filter((e) => e.timestamp >= query.since!);\n    }\n\n    if (query.before) {\n      results = results.filter((e) => e.timestamp <= query.before!);\n    }\n\n    if (query.shareLevel) {\n      results = results.filter((e) => e.metadata.shareLevel === query.shareLevel);\n    }\n\n    // Sort by timestamp (newest first)\n    results.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n\n    // Apply limit\n    if (query.limit) {\n      results = results.slice(0, query.limit);\n    }\n\n    this.logger.debug(`Recalled ${results.length} memories for query`);\n    return results;\n  }\n\n  async shareMemory(entryId: string, targetAgentId: string): Promise<void> {\n    const entry = this.entries.get(entryId);\n    if (!entry) {\n      throw new Error('Memory entry not found');\n    }\n\n    if (!this.config.enableCrossAgentSharing) {\n      throw new Error('Cross-agent sharing is disabled');\n    }\n\n    // Check share level permissions\n    if (entry.metadata.shareLevel === 'private') {\n      throw new Error('Memory entry is private and cannot be shared');\n    }\n\n    // Create a shared copy for the target agent\n    const sharedEntry: SwarmMemoryEntry = {\n      ...entry,\n      id: generateId('mem'),\n      metadata: {\n        ...entry.metadata,\n        originalId: entryId,\n        sharedFrom: entry.agentId,\n        sharedTo: targetAgentId,\n        sharedAt: new Date(),\n      },\n    };\n\n    this.entries.set(sharedEntry.id, sharedEntry);\n\n    // Associate with target agent\n    if (!this.agentMemories.has(targetAgentId)) {\n      this.agentMemories.set(targetAgentId, new Set());\n    }\n    this.agentMemories.get(targetAgentId)!.add(sharedEntry.id);\n\n    this.logger.info(`Shared memory ${entryId} from ${entry.agentId} to ${targetAgentId}`);\n    this.emit('memory:shared', { original: entry, shared: sharedEntry });\n  }\n\n  async broadcastMemory(entryId: string, agentIds?: string[]): Promise<void> {\n    const entry = this.entries.get(entryId);\n    if (!entry) {\n      throw new Error('Memory entry not found');\n    }\n\n    if (entry.metadata.shareLevel === 'private') {\n      throw new Error('Cannot broadcast private memory');\n    }\n\n    const targets =\n      agentIds || Array.from(this.agentMemories.keys()).filter((id) => id !== entry.agentId);\n\n    for (const targetId of targets) {\n      try {\n        await this.shareMemory(entryId, targetId);\n      } catch (error) {\n        this.logger.warn(`Failed to share memory to ${targetId}:`, error);\n      }\n    }\n\n    this.logger.info(`Broadcasted memory ${entryId} to ${targets.length} agents`);\n  }\n\n  async createKnowledgeBase(\n    name: string,\n    description: string,\n    domain: string,\n    expertise: string[],\n  ): Promise<string> {\n    const kbId = generateId('kb');\n    const knowledgeBase: SwarmKnowledgeBase = {\n      id: kbId,\n      name,\n      description,\n      entries: [],\n      metadata: {\n        domain,\n        expertise,\n        contributors: [],\n        lastUpdated: new Date(),\n      },\n    };\n\n    this.knowledgeBases.set(kbId, knowledgeBase);\n\n    this.logger.info(`Created knowledge base: ${name} (${kbId})`);\n    this.emit('knowledgebase:created', knowledgeBase);\n\n    return kbId;\n  }\n\n  async updateKnowledgeBase(entry: SwarmMemoryEntry): Promise<void> {\n    if (!this.config.enableKnowledgeBase) return;\n\n    // Find relevant knowledge bases\n    const relevantKBs = Array.from(this.knowledgeBases.values()).filter((kb) => {\n      // Simple matching based on tags and content\n      const tags = entry.metadata.tags || [];\n      return tags.some((tag) =>\n        kb.metadata.expertise.some(\n          (exp) =>\n            exp.toLowerCase().includes(tag.toLowerCase()) ||\n            tag.toLowerCase().includes(exp.toLowerCase()),\n        ),\n      );\n    });\n\n    for (const kb of relevantKBs) {\n      // Add entry to knowledge base\n      kb.entries.push(entry);\n      kb.metadata.lastUpdated = new Date();\n\n      // Add contributor\n      if (!kb.metadata.contributors.includes(entry.agentId)) {\n        kb.metadata.contributors.push(entry.agentId);\n      }\n\n      this.logger.debug(`Updated knowledge base ${kb.id} with entry ${entry.id}`);\n    }\n  }\n\n  async searchKnowledge(\n    query: string,\n    domain?: string,\n    expertise?: string[],\n  ): Promise<SwarmMemoryEntry[]> {\n    const allEntries: SwarmMemoryEntry[] = [];\n\n    // Search in knowledge bases\n    for (const kb of this.knowledgeBases.values()) {\n      if (domain && kb.metadata.domain !== domain) continue;\n\n      if (expertise && !expertise.some((exp) => kb.metadata.expertise.includes(exp))) {\n        continue;\n      }\n\n      allEntries.push(...kb.entries);\n    }\n\n    // Simple text search (in real implementation, use better search)\n    const queryLower = query.toLowerCase();\n    const results = allEntries.filter((entry) => {\n      const contentStr = JSON.stringify(entry.content).toLowerCase();\n      return contentStr.includes(queryLower);\n    });\n\n    return results.slice(0, 50); // Limit results\n  }\n\n  async getAgentMemorySnapshot(agentId: string): Promise<{\n    totalEntries: number;\n    recentEntries: SwarmMemoryEntry[];\n    knowledgeContributions: number;\n    sharedEntries: number;\n  }> {\n    const agentEntryIds = this.agentMemories.get(agentId) || new Set();\n    const agentEntries = Array.from(agentEntryIds)\n      .map((id) => this.entries.get(id))\n      .filter(Boolean) as SwarmMemoryEntry[];\n\n    const recentEntries = agentEntries\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())\n      .slice(0, 10);\n\n    const knowledgeContributions = agentEntries.filter((e) => e.type === 'knowledge').length;\n\n    const sharedEntries = agentEntries.filter(\n      (e) => e.metadata.shareLevel === 'public' || e.metadata.shareLevel === 'team',\n    ).length;\n\n    return {\n      totalEntries: agentEntries.length,\n      recentEntries,\n      knowledgeContributions,\n      sharedEntries,\n    };\n  }\n\n  private async loadMemoryState(): Promise<void> {\n    try {\n      // Load entries\n      const entriesFile = path.join(this.config.persistencePath, 'entries.json');\n      try {\n        const entriesData = await fs.readFile(entriesFile, 'utf-8');\n        const entriesArray = JSON.parse(entriesData);\n\n        for (const entry of entriesArray) {\n          this.entries.set(entry.id, {\n            ...entry,\n            timestamp: new Date(entry.timestamp),\n          });\n\n          // Rebuild agent memory associations\n          if (!this.agentMemories.has(entry.agentId)) {\n            this.agentMemories.set(entry.agentId, new Set());\n          }\n          this.agentMemories.get(entry.agentId)!.add(entry.id);\n        }\n\n        this.logger.info(`Loaded ${entriesArray.length} memory entries`);\n      } catch (error) {\n        this.logger.warn('No existing memory entries found');\n      }\n\n      // Load knowledge bases\n      const kbFile = path.join(this.config.persistencePath, 'knowledge-bases.json');\n      try {\n        const kbData = await fs.readFile(kbFile, 'utf-8');\n        const kbArray = JSON.parse(kbData);\n\n        for (const kb of kbArray) {\n          this.knowledgeBases.set(kb.id, {\n            ...kb,\n            metadata: {\n              ...kb.metadata,\n              lastUpdated: new Date(kb.metadata.lastUpdated),\n            },\n            entries: kb.entries.map((e: any) => ({\n              ...e,\n              timestamp: new Date(e.timestamp),\n            })),\n          });\n        }\n\n        this.logger.info(`Loaded ${kbArray.length} knowledge bases`);\n      } catch (error) {\n        this.logger.warn('No existing knowledge bases found');\n      }\n    } catch (error) {\n      this.logger.error('Error loading memory state:', error);\n    }\n  }\n\n  private async saveMemoryState(): Promise<void> {\n    try {\n      // Save entries\n      const entriesArray = Array.from(this.entries.values());\n      const entriesFile = path.join(this.config.persistencePath, 'entries.json');\n      await fs.writeFile(entriesFile, JSON.stringify(entriesArray, null, 2));\n\n      // Save knowledge bases\n      const kbArray = Array.from(this.knowledgeBases.values());\n      const kbFile = path.join(this.config.persistencePath, 'knowledge-bases.json');\n      await fs.writeFile(kbFile, JSON.stringify(kbArray, null, 2));\n\n      this.logger.debug('Saved memory state to disk');\n    } catch (error) {\n      this.logger.error('Error saving memory state:', error);\n    }\n  }\n\n  private async syncMemoryState(): Promise<void> {\n    try {\n      await this.saveMemoryState();\n      this.emit('memory:synced');\n    } catch (error) {\n      this.logger.error('Error syncing memory state:', error);\n    }\n  }\n\n  private async enforceMemoryLimits(): Promise<void> {\n    if (this.entries.size <= this.config.maxEntries) return;\n\n    this.logger.info('Enforcing memory limits...');\n\n    // Remove oldest entries that are not marked as important\n    const entries = Array.from(this.entries.values())\n      .filter((e) => (e.metadata.priority || 1) <= 1) // Only remove low priority\n      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n\n    const toRemove = entries.slice(0, this.entries.size - this.config.maxEntries);\n\n    for (const entry of toRemove) {\n      this.entries.delete(entry.id);\n\n      // Remove from agent memory\n      const agentEntries = this.agentMemories.get(entry.agentId);\n      if (agentEntries) {\n        agentEntries.delete(entry.id);\n      }\n\n      this.logger.debug(`Removed old memory entry: ${entry.id}`);\n    }\n\n    this.emit('memory:cleaned', toRemove.length);\n  }\n\n  // Public API methods\n  getMemoryStats(): {\n    totalEntries: number;\n    entriesByType: Record<string, number>;\n    entriesByAgent: Record<string, number>;\n    knowledgeBases: number;\n    memoryUsage: number;\n  } {\n    const entries = Array.from(this.entries.values());\n    const entriesByType: Record<string, number> = {};\n    const entriesByAgent: Record<string, number> = {};\n\n    for (const entry of entries) {\n      entriesByType[entry.type] = (entriesByType[entry.type] || 0) + 1;\n      entriesByAgent[entry.agentId] = (entriesByAgent[entry.agentId] || 0) + 1;\n    }\n\n    // Rough memory usage calculation\n    const memoryUsage = JSON.stringify(entries).length;\n\n    return {\n      totalEntries: entries.length,\n      entriesByType,\n      entriesByAgent,\n      knowledgeBases: this.knowledgeBases.size,\n      memoryUsage,\n    };\n  }\n\n  async exportMemory(agentId?: string): Promise<any> {\n    const entries = agentId ? await this.recall({ agentId }) : Array.from(this.entries.values());\n\n    return {\n      entries,\n      knowledgeBases: agentId\n        ? Array.from(this.knowledgeBases.values()).filter((kb) =>\n            kb.metadata.contributors.includes(agentId),\n          )\n        : Array.from(this.knowledgeBases.values()),\n      exportedAt: new Date(),\n      stats: this.getMemoryStats(),\n    };\n  }\n\n  async clearMemory(agentId?: string): Promise<void> {\n    if (agentId) {\n      // Clear specific agent's memory\n      const entryIds = this.agentMemories.get(agentId) || new Set();\n      for (const entryId of entryIds) {\n        this.entries.delete(entryId);\n      }\n      this.agentMemories.delete(agentId);\n      this.logger.info(`Cleared memory for agent ${agentId}`);\n    } else {\n      // Clear all memory\n      this.entries.clear();\n      this.agentMemories.clear();\n      this.knowledgeBases.clear();\n      this.logger.info('Cleared all swarm memory');\n    }\n\n    this.emit('memory:cleared', { agentId });\n  }\n\n  // Compatibility methods for hive.ts\n  async store(key: string, value: any): Promise<void> {\n    // Extract namespace and actual key from the path\n    const parts = key.split('/');\n    const type = (parts[0] as SwarmMemoryEntry['type']) || 'state';\n    const agentId = parts[1] || 'system';\n\n    await this.remember(agentId, type, value, {\n      tags: [parts[0], parts[1]].filter(Boolean),\n      shareLevel: 'team',\n    });\n  }\n\n  async search(pattern: string, limit: number = 10): Promise<any[]> {\n    // Simple pattern matching on stored keys/content\n    const results: any[] = [];\n\n    for (const entry of this.entries.values()) {\n      const entryString = JSON.stringify(entry);\n      if (entryString.includes(pattern.replace('*', ''))) {\n        results.push(entry.content);\n        if (results.length >= limit) break;\n      }\n    }\n\n    return results;\n  }\n}\n"],"names":["EventEmitter","Logger","MemoryManager","EventBus","generateId","fs","path","SwarmMemoryManager","logger","config","baseMemory","entries","knowledgeBases","agentMemories","syncTimer","isInitialized","namespace","enableDistribution","enableReplication","syncInterval","maxEntries","compressionThreshold","enableKnowledgeBase","enableCrossAgentSharing","persistencePath","Map","eventBus","getInstance","backend","cacheSizeMB","syncOnExit","ttlMinutes","initialize","info","mkdir","recursive","loadMemoryState","setInterval","syncMemoryState","emit","shutdown","clearInterval","undefined","saveMemoryState","remember","agentId","type","content","metadata","entryId","entry","id","timestamp","Date","shareLevel","priority","set","has","Set","get","add","key","JSON","stringify","entryType","debug","updateKnowledgeBase","enforceMemoryLimits","recall","query","results","Array","from","values","filter","e","taskId","objectiveId","tags","length","some","tag","includes","since","before","sort","a","b","getTime","limit","slice","shareMemory","targetAgentId","Error","sharedEntry","originalId","sharedFrom","sharedTo","sharedAt","original","shared","broadcastMemory","agentIds","targets","keys","targetId","error","warn","createKnowledgeBase","name","description","domain","expertise","kbId","knowledgeBase","contributors","lastUpdated","relevantKBs","kb","exp","toLowerCase","push","searchKnowledge","allEntries","queryLower","contentStr","getAgentMemorySnapshot","agentEntryIds","agentEntries","map","Boolean","recentEntries","knowledgeContributions","sharedEntries","totalEntries","entriesFile","join","entriesData","readFile","entriesArray","parse","kbFile","kbData","kbArray","writeFile","size","toRemove","delete","getMemoryStats","entriesByType","entriesByAgent","memoryUsage","exportMemory","exportedAt","stats","clearMemory","entryIds","clear","store","value","parts","split","search","pattern","entryString","replace"],"mappings":"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"}